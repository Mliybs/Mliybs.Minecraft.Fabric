# 开发范式

`Mliybs.Minecraft.Fabric`是一个Java绑定库，因此会大量与指针，非托管代码打交道，它尽力提供与编写正常C#代码相同的感受，但该绑定库内部具有一部分的约定俗成内容，这是Java绑定的限制所致，因此才有了这份开发范式来帮助开发者进行开发

> 值得注意的是，**该开发范式是帮助编写此Java绑定库的，而不是该库的使用指南**

## 内置接口与抽象类

`Mliybs.Minecraft.Fabric`内置了数个接口与抽象类，分别代表不同的含义

需要注意的是，这些接口与抽象类大多只表示某些意义，几乎不会将它们作为参数类型 _（因为它们大多是用来包含静态抽象成员的）_

由于抽象类不支持静态抽象成员，所以一个类有的时候必须分别继承抽象类和接口，这一点需要注意

### IClassRef接口

`IClassRef`指示一个类具有相对应的Java类绑定，但它**不一定是可作为Java对象的，也不一定具有Java构造函数**

如果一个`IClassRef`的实现类对应的是**混淆代码**，则**应**具有静态`Names`只读字段，该字段负责提供中间名与运行时Java类名的映射结果

### IConstructor接口

`IConstructor`指示一个类在具有Java类绑定的基础上，还具有Java构造函数，可作为Java对象，它继承自`IClassRef`，**实现该接口的C#类可以通过实例化C#对象来实例化相对应的Java对象**

虽然此时它与`JavaClass`没有继承关系，但子类应该同时继承它们两个

### JavaClass抽象类

`JavaClass`指示一个类可作为Java对象，它不一定具有Java构造函数，但它自己具有传入指针的C#构造函数，即**可以将Java方传递过来的对象指针作为C#对象表示**

`JavaClass`还具有自主全局引用管理，会将每一个Java对象的局部引用更改为全局引用存储在自身的`ObjectRef`属性下，并使用**终结器**_（析构函数）_ 释放，这样做能保证**C#对象的生命周期不会长于相对应的Java对象，在C#对象还没有被释放的时候是一定能访问到相对应的Java对象的**

在继承的时候应同时与`IClassRef`或`IConstructor`进行继承，如果对应的Java类具有可用的公共构造函数则应使用后者，否则使用前者

### IWrapper接口

IWrapper指示一个类可以被正常继承，它继承自`IConstructor`

由于此库不具有动态生成`Java`类的能力，因此我们退而求其次，利用Java包装类只为部分类提供了继承功能（如`Item`类），这意味着，**只有实现该接口的C#类可被正常继承进行诸如覆写基类方法的操作，继承未实现该接口的C#类是没有任何意义的**